\documentclass[10pt, openany]{book}

\usepackage{fancyhdr}
\usepackage{imakeidx}

\usepackage{amsmath}
\usepackage{amsfonts}

\usepackage{geometry}
\geometry{letterpaper}

\usepackage{fancyvrb}
\usepackage{fancybox}
%
% Rules to allow import of graphics files in EPS format
%
\usepackage{graphicx}
\DeclareGraphicsExtensions{.eps}
\DeclareGraphicsRule{.eps}{eps}{.eps}{}
%
%  Include the listings package and define Pseudo Code
%
\usepackage{listings}
%
% Macro definitions
%
\newcommand{\operation}[1]{\textbf{\texttt{#1}}}
\newcommand{\package}[1]{\texttt{#1}}
\newcommand{\function}[1]{\texttt{#1}}
\newcommand{\constant}[1]{\emph{\texttt{#1}}}
%
% Front Matter
%
\title{Tiny Lisp Interpreter}
\author{Brent Seidel \\ Phoenix, AZ}
\date{ \today }
%========================================================
%%% BEGIN DOCUMENT
\begin{document}
%
% Produce the front matter
%
\frontmatter
\maketitle
\begin{center}
This document is \copyright 2020 Brent Seidel.  All rights reserved.

\paragraph{}Note that this is a draft version and not the final version for publication.
\end{center}
\tableofcontents

\mainmatter
%----------------------------------------------------------
\chapter{Introduction}
This document provides a definition of a Tiny Lisp interpreter written in Ada.  Without such a definition, it is difficult to determine if the language is actually doing what it should be doing.  This makes debugging more complicated.

\section{What is This?}
This is a tiny Lisp interpreter written in Ada.  It is designed to proved a language that can be embedded into other programs, including running on embedded systems without an operating system.  As a result, effort has been made to remove dependencies on Ada packages that may not be available.  A primary example is \package{Ada.Text\_IO}.  Another feature that may be missing is dynamic memory allocation.

\section{Why is This?}
As a young lad, I learned to program on 8-bit computers with minimal BASIC interpreters and 4-16K of RAM.  With these simple systems, one had a hope of being able to understand the complete system at a fairly low level.  Now, one can buy small computers like the Arduino Due with 32-bit processors, 96K of RAM, and 512K of flash memory (I'm ignoring systems like the Raspberry PI as they are full up Linux computer and thus are more complicated).  This seemed like a reasonable platform for recreating the early experience.

\subsection{Why Lisp?}
Why not?  My first thought was to use some flavor of Tiny BASIC which would have more in common with those early systems.  I then realized that Lisp is much easier to parse.  Being somewhat lazy and interested in various computer languages, I decided that some form of a ``Tiny-Lisp'' would be a good idea.

\subsection{Why Ada?}
Again, why non?  I have developed an interest in Ada, especially for programming embedded systems.  It has features, such as strong typing, which can help to catch errors early, thus saving time debugging.  I would not claim to be the world's greatest programmer, so I need all the help that I can get.

%----------------------------------------------------------
\chapter{The Language}
As a ``Tiny-Lisp'', some (many) of the features of Common Lisp are not available.  Some of the lacks may be temporary while others will be permanent, and some may be added by the host program.

\section{User Interface}
The interpreter reads text from an input device, parses it, and and executes it.  The function used to read the input must match the signature for \function{Ada.Text\_IO.Get\_Line()} and this will probably be used if that is available.  On an embedded system without \package{Ada.Text\_IO}, the user must provide a suitable function.

\subsubsection{Comments}
A comment starts with a semicolon character, ``;'', and extends to the end of the line.  Any text in a comment is ignore by the interpreter.

\subsubsection{Continuation}
If a list isn't closed (number of open parentheses matches the number of close parentheses) by the end of the line, the interpreter will ask for more text.  This will continue until the list is closed.

\section{Syntax}

\subsection{Special Characters}
There are only a few characters with special significance.  Parenthesis, ``('' and ``)'', are used for delimiting lists.  Quotation marks, ``"'' are used for delimiting strings.  The semicolon, ``;'', indicates a comment.  Spaces are used to separate elements in a list.  That's about it.  However, it's probably best to avoid most symbol characters and some more special characters may be added.

\subsection{Reserved Words}
There are none, however you can't define a symbol that it already used for a builtin or special operation.

\subsection{Examples}
The basic syntax for languages in the Lisp family is very simple.  Everything is a list of elements, where each element may also be a list.  Elements are separated by spaces and the list is contained in parentheses.  Here is a simple list:
\lstset{language=Lisp}
\begin{lstlisting}
(+ 1 2 3)
\end{lstlisting}
The first element in the list is the symbol ``+''.  The following elements are ``1'', ``2'', and ``3''.  The ``+'' symbol is the addition operation and adds the following integers together.  Thus, the example would return the integer ``6''.

A more complicated example:
\begin{lstlisting}
(+ (* 2 3) (* 4 5))
\end{lstlisting}
This is equivalent to $2*3+4*5$.  Breaking this down, the first element of the outside list is ``+''.  The second element is the list ``(* 2 3)'' and the third element is the list ``(* 4 5)''.  Since ``*'' is the symbol for the multiplication operation, this returns a value of 26.

A final example:
\begin{lstlisting}
(print "Hello World!")
\end{lstlisting}
This list consists of only two elements.  The first is the symbol \operation{print}.  The second is the string ``Hello World!''.  With strings, everything from the starting quotation mark to the next quotation mark is part of the string.  This means that you can't have a string that contains a quotation mark (at some point, a work-around may be available).

\section{Operations}
A limited number of operations are defined.  Note that this list will probably be expanded.
\subsection{Normal Forms}
A number of normal forms are defined.  The main difference between normal forms and special forms is that all active arguments for a normal form are evaluated.  Thus:
\begin{lstlisting}
(* (+ 1 2) (+ 3 4))
;
; Versus
;
(if (> 1 2) (+ 1 2) (+ 3 4))
\end{lstlisting}
``*'' is a normal operation and both ``(+ 1 2)'' and ``(+ 3 4)'' are evaluated before ``*'' is evaluated.  \operation{If} is a special form so first ``(> 1 2)'' is evaluated, then depending on whether the result is true or false, either ``(+ 1 2)'' or ``(+ 3 4)'' is evaluated.  For a simple example like this, it doesn't really matter, but if the operations have other effects, such as:
\begin{lstlisting}
(if (> 1 2) (print "Greater") (print "Not greater"))
\end{lstlisting}
will only print ``Not greater''.

\subsubsection{Arithmatic Operations}
Four arithmatic operations are defined for operation on integers.  The operations are addition, subtraction, multiplication, and division.  For example:
\begin{lstlisting}
(+ 1 2 3 4)
(- 1 2 3 4)
(* 1 2 3 4)
(/ 1 2 3 4)
\end{lstlisting}
These operations work on a list of one or more parameters, with the operation inserted between the parameters.  Thus (+ 1 2 3 4 ) computes as $1+2+3+4$.  The return value for each of these operations is an integer value.

\subsubsection{Comparison Operations}
Four comparison operations are defined for both integers and strings.  The operations are equals, not equals, greater than, and less than.  For example:
\begin{lstlisting}
(= 1 2)
(/= 1 2)
(< 1 2)
(> 1 2)
\end{lstlisting}
These operations work on two parameters of the same type.  The return value of each of these operations is a boolean.

\subsubsection{Input/Output}
As this Lisp may run on systems without filesystems, only three operations are provided for input and output.  These are:
\begin{lstlisting}
(print "Strings " 1 2 N)
(new-line)
(read-line)
\end{lstlisting}
The \operation{print} operation evaluates each item in its parameter list and prints the value.  The \operation{new-line} operation simply prints a new line.  The \operation{read-line} operation reads a string from the input device and returns it.  Both print and new-line return NIL.  Read-line returns the entered string with no line terminator.

\subsubsection{List Operations}
Basic list operations are provided.
\begin{lstlisting}
(car (1 2 3 4))
(cdr (1 2 3 4))
\end{lstlisting}
Each of \operation{car} and \operation{cdr} take one parameter that should be a list.  \operation{Car} returns the first item in the list.  This item may be a single element or it may be a list.  \operation{Cdr} returns the remainder of the list.

\subsubsection{Debugging}
Some additional operations are provided for debugging purposes.  These control the display of some debugging information.
\begin{lstlisting}
(dump)
(msg-on)
(msg-off)
(reset)
\end{lstlisting}

The \operation{dump} operation prints the contents of the cons, symbol, and string tables.  The \operation{msg-on} and \operation{msg-off} operations turn the display of debugging information on and off.  These are helpful when trying to debug the interpreter and should not be necessary during normal operation.

The \operation{reset} operation is intended to reset the interpreter to an initial state.  Currently, it just calls the \function{init()} function.  It needs to go through the symbol table and remove everything that's not a \constant{builtin} and clear out the cons table.  Do not use until this is fixed.

\subsubsection{Other}
There are a few operations that do things that can't be easily categorized.
\begin{lstlisting}
(exit)
\end{lstlisting}
The \operation{exit} operation just exits the interpreter.  It should mainly be used from the command line.  It may cause problems in some cases if used in a function.

\subsection{Special Forms}
The special forms do not necessarily evaluate all of the parameters.

\subsubsection{Control Flow}
A couple of control flow special forms are available.  More will probably be added.
\begin{lstlisting}
(if (> 1 2) (print "True") (print "False"))
(dowhile (> 1 2) (print "Forever"))
\end{lstlisting}
The \operation{if} form has two or three parameters.  The first parameter is a condition.  If the condition evaluates to ``T'', then the second parameter is evaluated.  If the condition evaluates to ``NIL'', then the third parameter, if present, is evaluated.

The \operation{dowhile} form has two parameters.  The first is a condition.  The second is a list of operations to be evaluated.  The second parameter is evaluated as long as the condition evaluates to ``T''.

\subsubsection{Variables}
\begin{lstlisting}
(setq variable 1)
\end{lstlisting}
The \operation{setq} form sets a value for a symbol.  The first parameter is the symbol and the second parameter is the value.  If the symbol does not yet exist, it is created.  Symbols that already exist as builtin or lambdas can't be used for values.  The second parameter is evaluated to return the value.  Currently this only works on global variables, not parameters or local variables (which are currently unimplemented anyway).

\lstset{language=Ada}
\begin{lstlisting}
      add_builtin("defun", BBS.lisp.evaluate.defun'Access);
      add_builtin("quote", BBS.lisp.evaluate.quote'Access);
\end{lstlisting}

\section{Data Types}
A limited selection of data types is provided.  Think of the old Applesoft Integer BASIC.

\subsection{Integer}
This is the same as the Ada Integer type.  Typically it is a 32 bit signed integer.

\subsection{String}
Strings are stored in linked lists of 8-bit characters/bytes.  Each node in the list can hold 16 (adjustable by a parameter) bytes.  Unicode is not currently supported.

\subsection{Boolean}
The Boolean values ``NIL'' and ``T'' correspond to ``True'' and ``False''.

\subsection{List}
The list is the basic complex data type.  A list element has two slots (historically called ``car'' and ``cdr'').  Typically the ``car'' slot contains a data value and the ``cdr'' slot contains a pointer to the next list element.  The end of a list is indicated by a nil value in the ``cdr'' slot.

\subsection{Possible Additions}
A stack may be added to hold stack frames for parameters and local variables.

%----------------------------------------------------------
\chapter{Internals}
As the interpreter is under active development, this section is subject to change without notice.
\section{Data Structures}
\subsection{Elements}
The basic data type is the element.  It is defined as follows:
\lstset{language=Ada}
\begin{lstlisting}
   type element_type(kind : ptr_type := E_NIL) is
      record
         case kind is
            when E_CONS =>
               ps : cons_index;
            when E_NIL =>
               null;
            when E_VALUE =>
               v : value;
            when E_SYMBOL =>
               sym : symb_index;
            when E_TEMPSYM =>
               tempsym : tempsym_index;
            when E_PARAM =>
               p_name : string_index;
               p_value : value;
            when E_LOCAL =>
               l_name : string_index;
               l_value : value;
         end case;
      end record;
\end{lstlisting}
The referenced types are defined as follows:
\begin{lstlisting}
   max_cons : constant Integer := 300;
   max_symb : constant Integer := 200;
   max_tempym : constant Integer := 50;
   max_string : constant Integer := 500;
   type cons_index is range 0 .. max_cons;
   type symb_index is range 0 .. max_symb;
   type tempsym_index is range 0 .. max_tempym;
   type string_index is range 0 .. max_string;
   type ptr_type is (E_CONS, E_NIL, E_VALUE, E_SYMBOL,
                     E_TEMPSYM, E_PARAM, E_LOCAL);
   type value_type is (V_INTEGER, V_STRING, V_CHARACTER, V_BOOLEAN,
                       V_LIST);
   type value(kind : value_type := V_INTEGER) is
      record
         case kind is
         when V_INTEGER =>
            i : Integer;
         when V_CHARACTER =>
            c : Character;
         when V_STRING =>
            s : string_index;
         when V_BOOLEAN =>
            b : Boolean;
         when V_LIST =>
            l : cons_index;
         end case;
      end record;
\end{lstlisting}

There is a bit of ambiguity right now about lists.  Since recursively defined records aren't possible, elements of type \constant{E\_PARAM} or \constant{E\_LOCAL} can't contain an \emph{element\_type}.  So in order for them to be able to have lists, the \emph{value} type also contains a list pointer.  This means that right now, an \emph{element\_type} can point to a list either directly by having a kind of \constant{E\_CONS}, or by having a kind that contains a \emph{value} with a kind of \constant{V\_LIST}.  This really should be fixed at some point.  On the other hand, one could make the distinction that the kind \constant{E\_CONS} represents a list that can be evaluated, while a \emph{value} of kind \constant{V\_LIST} is just data.

\subsection{Cons}
Cons elements are used to make lists.  A cons cell is defined as
\begin{lstlisting}
   type cons is
      record
         ref : Natural;
         car : element_type;
         cdr : element_type;
      end record;
\end{lstlisting}

\subsection{Symbols}
Symbols are defined as:
\begin{lstlisting}
   type symbol_type is (BUILTIN, LAMBDA, VARIABLE, EMPTY);
   type execute_function is access function(e : element_type)
     return element_type;
   type symbol(kind : symbol_type := EMPTY) is
      record
         ref : Natural;
         str : string_index;
         case kind is
            when BUILTIN =>
               f : execute_function;
            when LAMBDA =>
               ps : cons_index;
            when VARIABLE =>
               pv : element_type;
            when EMPTY =>
               null;
         end case;
      end record;
\end{lstlisting}

\subsection{Strings}
Strings are stored as a set of string fragments in a linked list.  Thus, the length of a string is limited only by the number of fragments available.  Strings are defined as:
\begin{lstlisting}
   fragment_len : constant Integer := 16;
   type fragment is
      record
         ref : Natural;
         next : Integer range -1 .. Integer(string_index'Last);
         len : Integer range 0..fragment_len;
         str : String (1..fragment_len);
      end record;
\end{lstlisting}

\subsection{Global Data}

\subsection{Memory Management}
Memory management is done by reference counting.  When the number of references goes to zero, the item is deallocated.  Items in the cons table and the strings table are reference counted.

\section{Utility Functions}

\section{Embedding}
This section covers how to embed the list interpreter in another program.

\end{document}

