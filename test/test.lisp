;
;  Test functions for the Tiny Lisp Interpreter.  This file has been
;  designed so that it can be sourced to the lisp interpreter via a
;  command like:
;
;  ./lisp < test.lisp
;
;  These tests more or less proceed in increasing complexity where later tests
;  depend on items from earlier tests working correctly.  There are some things
;  that are not explicitly tested, such as defun, but are used throughout so
;  failures should be obvious with other things not working properly.
;
;-----------------------------------------
;  Support functions.  Load these first.
;
;  Initialize global counters
;
(setq *PASS-COUNT* 0)
(setq *FAIL-COUNT* 0)
;
;
;  If two values are equal, print pass message, otherwise print fail message
;
(defun verify-equal (expected actual text)
  (if (= expected actual)
    (progn (setq *PASS-COUNT* (+ *PASS-COUNT* 1)) (print "PASS: Actual "))
    (progn (setq *FAIL-COUNT* (+ *FAIL-COUNT* 1)) (print "***FAIL: Actual ")))
  (print  actual ", Expected " expected " " text)
  (terpri))
;
;  Check if a value is true
;
(defun verify-true (act text-msg)
  (verify-equal T act text-msg))
;
;  Check if a value is false
;
(defun verify-false (act text-msg)
  (verify-equal NIL act text-msg))
;
;  Print summary results
;
(defun summary ()
  (print "Test cases passed: " *PASS-COUNT*)
  (terpri)
  (print "Test cases failed: " *FAIL-COUNT*)
  (terpri)
  (print "Total test cases:  " (+ *PASS-COUNT* *FAIL-COUNT*)))
;--------------------------------------------
;  Test cases.  Load and run the desired test.
;
;  Test if and booleans
;
(print "===> Testing booleans")
(terpri)
(defun test-bool ()
  (verify-true (= T T) "T literal is equal to itself")
  (verify-true (= NIL NIL) "NIL literal is equal to itself")
  (verify-false (= NIL T) "NIL and T literals are not equal")
  (verify-true (= T (= 1 1)) "T literal is equal to a true condition")
  (verify-false (= T (= 1 2)) "T literal is not equal to a false condition")
  (verify-true (= NIL (= 1 2)) "NIL literal is equal to a false condition")
  (verify-false (= NIL (= 1 1)) "T literal is not equal to a true condition"))
(test-bool)
(setq test-bool 0)
;
;  Test integer comparisons
;
(print "===> Testing integer comparisons")
(terpri)
(defun test-int-cmp ()
  (verify-true (= 0 0) "0 = 0")
  (verify-false (< 0 0) "not 0 < 0")
  (verify-false (> 0 0) "not 0 > 0")
  (verify-false (/= 0 0) "not 0 /= 0")
  (verify-false (= 2 1) "not 2 = 1")
  (verify-false (< 2 1) "not 2 < 1")
  (verify-true (> 2 1) "2 > 1")
  (verify-true (/= 2 1) "2 /= 1")
  (verify-false (= -1 1) "not -1 = 1")
  (verify-true (< -1 1) "-1 < 1")
  (verify-false (> -1 1) "not -1 > 1")
  (verify-true (/= -1 1) "-1 /= 1")
  (verify-false (= -2 -1) "not -2 = -1")
  (verify-true (< -2 -1) "-2 < -1")
  (verify-false (> -2 -1) "not -2 > -1")
  (verify-true (/= -2 -1) "-2 /= -1"))
(test-int-cmp)
(setq test-int-cmp 0)
;
;  Test string comparisons
;
(print "===> Testing string comparisons")
(terpri)
(defun test-str-cmp ()
  (verify-true (= "A" "A") "A = A")
  (verify-false (< "A" "A") "not A < A")
  (verify-false (> "A" "A") "not A > A")
  (verify-false (/= "A" "A") "not A /= A")
  (verify-false (= "A" "B") "not A = B")
  (verify-true (< "A" "B") "A < B")
  (verify-false (> "A" "B") "not A > B")
  (verify-false (= "C" "B") "not C = B")
  (verify-true (/= "C" "B") "C /= B")
  (verify-false (< "C" "B") "C < B")
  (verify-true (> "C" "B") "not C > B")
  (verify-true (/= "A" "B") "A /= B")
  (verify-false (= "A" "AA") "not A = AA")
  (verify-true (< "A" "AA") "A < AA")
  (verify-false (> "A" "AA") "not A > AA")
  (verify-true (/= "A" "AA") "A /= AA")
  (verify-false (= "AAAAAAAAAAAAAAAA" "AAAAAAAAAAAAAAAAA") "not AAAAAAAAAAAAAAAA = AAAAAAAAAAAAAAAAA")
  (verify-true (< "AAAAAAAAAAAAAAAA" "AAAAAAAAAAAAAAAAA") "AAAAAAAAAAAAAAAA < AAAAAAAAAAAAAAAAA")
  (verify-false (> "AAAAAAAAAAAAAAAA" "AAAAAAAAAAAAAAAAA") "not AAAAAAAAAAAAAAAA > AAAAAAAAAAAAAAAAA")
  (verify-true (/= "AAAAAAAAAAAAAAAA" "AAAAAAAAAAAAAAAAA") "AAAAAAAAAAAAAAAA /= AAAAAAAAAAAAAAAAA"))
(test-str-cmp)
(setq test-str-cmp 0)
;
;  Test boolean comparisons
;
(print "===> Testing boolean comparisons")
(terpri)
(defun test-bool-cmp ()
  (verify-true (= T T) "True is true")
  (verify-false (/= T T) "not T /= T")
  (verify-false (< T T) "not T < T")
  (verify-false (> T T) "not T > T")
  (verify-true (= NIL NIL) "False is false")
  (verify-false (/= NIL NIL) "not NIL /= NIL")
  (verify-false (< NIL NIL) "not NIL < NIL")
  (verify-false (> NIL NIL) "not NIL > NIL")
  (verify-true (> T NIL) "T > NIL")
  (verify-true (< NIL T) "NIL < T")
  (verify-false (= NIL T) "not NIL = T")
  (verify-true (/= T NIL) "T /= NIL")
  (verify-false (> NIL T) "not NIL > T")
  (verify-false (< T NIL) "not T < NIL"))
(test-bool-cmp)
(setq test-bool-cmp 0)
;
;  Test symbol comparisons
;
(print "===> Testing symbol comparisons")
(terpri)
(defun test-sym-comp ()
  (verify-true (= 'print 'print) "Print is equal to itself")
  (verify-false (/= 'print 'print) "not print /= print")
  (verify-false (= 'print 'terpri) "not print = terpri")
  (verify-true (/= 'terpri 'print) "terpri is not print"))
(test-sym-comp)
(setq test-sym-comp 0)
;
;  Test basic math functions
;
(print "===> Testing basic math operations")
(terpri)
(defun test-basic-math ()
  (verify-equal 6 (+ 1 2 3) "Add positive")
  (verify-equal 0 (+ 1 2 -3) "Add mixed")
  (verify-equal -6 (+ -1 -2 -3) "Add negative")
  (verify-equal 24 (* 2 3 4) "Mul positive")
  (verify-equal -24 (* -2 3 4) "Mul mixed")
  (verify-equal 24 (* -6 -4) "Mul negative")
  (verify-equal -4 (- 1 2 3) "Sub result negative")
  (verify-equal 3 (- 4 1) "Sub positive")
  (verify-equal 1 (- -2 -3) "Sub negative")
  (verify-equal -5 (- -2 3) "Sub mixed")
  (verify-equal 2 (/ 24 3 4) "Div positive")
  (verify-equal -8 (/ -24 3) "Div mixed")
  (verify-equal 8 (/ -24 -3) "Div negative")
  (verify-equal 4 (/ 24 5) "Div inexact"))
(test-basic-math)
(setq test-basic-math 0)
;
;  Test symbols/global variables with setq
;
(print "===> Testing symbols/globals")
(terpri)
(defun test-global ()
  (setq **GLOB** 1)
  (verify-equal 1 **GLOB** "Set global variable")
  (setq **GLOB** (+ 1 **GLOB**))
  (verify-equal 2 **GLOB** "Increment global")
  (setq **GLOB** "Hello")
  (verify-equal "Hello" **GLOB** "Set global to string"))
(test-global)
(setq test-global 0)
;
;  Test local variables with let and setq
;
(print "===> Testing let")
(terpri)
(defun test-let ()
  (let ((a (+ 1 2)) (b 4) (c 0) (d (1 2 3)) (test-let "A"))
    (verify-equal 3 a "A is 3")
    (verify-equal 4 b "B is 4")
    (verify-equal 0 c "C is 0")
    (verify-equal 1 (car d) "First element of D is 1")
    (verify-equal 3 (length d) "Length of D is 3")
    (setq d (4 5 6 7))
    (verify-equal 4 (length d) "Length of D is now 4")
    (verify-equal 4 (car d) "First element of D is 4")
    (setq a (+ 1 a))
    (verify-equal 4 a "A is 4")
    (setq b -10)
    (verify-equal -10 b  "B is -10")
    (setq c (+ a 2))
    (verify-equal 6 c "C is 6")
    (verify-equal "A" test-let "Locally, test-let is <A>")
    (let ((a 1))
      (verify-equal 1 a "A is 1")
      (setq a 20)
      (verify-equal 20 a "A is 20"))
    (verify-equal 4 a "A is 4"))
  (let ((a 1))
    (if NIL (setq a 10))
    (verify-equal 1 a "One branch if not executed")
    (if T (setq a 10))
    (verify-equal a 10 "One branch if executed")))
(test-let)
(setq test-let 0)
;
;  Test dowhile operation
;
(print "===> Testing dowhile")
(terpri)
(defun test-dowhile ()
  (let ((count 0) (accum 0))
    (dowhile (< count 10)
      (setq count (+ count 1))
      (setq accum (+ accum count))
      (print "Counter is " count ", Accumulator is " accum)
      (terpri))
    (verify-equal 10 count "Count is 10")
    (verify-equal 55 accum "Accumulator is 55")))
(test-dowhile)
(setq test-dowhile 0)
;
;  Test dolist operation
;
(print "===> Testing dolist")
(terpri)
(defun test-dolist ()
  (let ((accum 0) result)
    (setq result (dolist (n (1 3 5 7 11) 20)
      (setq accum (+ accum n))))
    (verify-equal 20 result "Result returned")
    (verify-equal 27 accum "Accumulator is 27")
    (setq accum 0)
    (setq result 5)
    (dolist (n (1 3 "Hello" result))
      (if (integerp n) (setq accum (+ accum n)))
      (if (stringp n) (verify-equal "Hello" n "Got a string in the list")))
    (verify-equal 9 accum "Accumulator is 9")))
(test-dolist)
(setq test-dolist 0)
;
;  Test dotimes operation
;
(print "===> Testing dotimes")
(terpri)
(defun test-dotimes ()
  (let ((accum 0) result)
    (setq result (dotimes (n 10 20)
      (print "Count is " n)
      (terpri)
      (setq accum (+ accum n))))
    (verify-equal 20 result "Result returned")
    (verify-equal 45 accum "Accumulator is 45")))
(test-dotimes)
(setq test-dotimes 0)
;
;  Test progn and return
;
(print "===> Testing block related operations")
(terpri)
(defun test-block ()
  (let ((accum 0) (count 0) result)
    (setq result (dowhile (< count 10)
      (print "Count is " count)
      (terpri)
      (if (= count 5)
        (progn
          (verify-equal 5 count "Loop at 5")
          (return 50)
          (verify-equal 1 2 "Return operation failed")))
       (setq count (+ 1 count))))
    (verify-equal 50 result "Checking result from return")
    (verify-equal 5 count "Loop exited at count = 5")
    (setq count T)
    (setq accum 0)
    (dowhile count (if (= accum 5) (setq count NIL)) (setq accum (+ accum 1)))
    (verify-equal 6 accum "Accumulator is 6")
    (verify-equal NIL count "Count is set to NIL")))
(test-block)
(setq test-block 0)
;
;  Test Hex number representation
;
(print "===> Testing hexidecimal numbers")
(terpri)
(defun test-hex ()
  (verify-equal #x0 0 "Digit 0")
  (verify-equal #x1 1 "Digit 1")
  (verify-equal #x2 2 "Digit 2")
  (verify-equal #x3 3 "Digit 3")
  (verify-equal #x4 4 "Digit 4")
  (verify-equal #x5 5 "Digit 5")
  (verify-equal #x6 6 "Digit 6")
  (verify-equal #x7 7 "Digit 7")
  (verify-equal #x8 8 "Digit 8")
  (verify-equal #x9 9 "Digit 9")
  (verify-equal #xA 10 "Digit A")
  (verify-equal #xB 11 "Digit B")
  (verify-equal #xC 12 "Digit C")
  (verify-equal #xD 13 "Digit D")
  (verify-equal #xE 14 "Digit E")
  (verify-equal #xF 15 "Digit F")
  (verify-equal #xFF 255 "Hex FF")
  (verify-equal #x1000 4096 "Hex 1000"))
(test-hex)
(setq test-hex 0)
;
;  Test logical operations
;
(print "===> Testing logic operations")
(terpri)
(defun test-logic ()
  (verify-equal NIL (not T) "T -> NIL")
  (verify-equal T (not NIL) "NIL -> T")
  (verify-equal #x0000FFFF (not #xFFFF0000) "#xFFFF0000 -> #x0000FFFF")
  (verify-equal #xA5A5A5A5 (not #x5A5A5A5A) "#x5A5A5A5A -> #xA5A5A5A5")
  (verify-equal NIL (and NIL NIL) "NIL and NIL -> NIL")
  (verify-equal NIL (and NIL T) "NIL and T -> NIL")
  (verify-equal NIL (and T NIL) "T and NIL -> NIL")
  (verify-equal T (and T T) "T and T -> T")
  (verify-equal NIL (or NIL NIL) "NIL or NIL -> NIL")
  (verify-equal T (or NIL T) "NIL or T -> T")
  (verify-equal T (or T NIL) "T or NIL -> T")
  (verify-equal T (or T T) "T or T -> T")
  (verify-equal 0 (and 15 4 3) "Produces zero")
  (verify-equal 15 (and #xF0F #xF01F)  "Produces 15")
  (verify-equal 7 (or 1 2 4) "Produces 7")
  (verify-equal #xF0F0 (or #xF000 #xF0) "Produces #xF0F0")
  (verify-equal T (not (and T NIL)) "T nand NIL -> T"))
(test-logic)
(setq test-logic 0)
;
;  Test character data type and operations.  Some of these tests assume
;  ASCII encoding.
;
(print "===> Testing characters")
(terpri)
(defun test-char ()
  (verify-true (= #\A #\A) "A = A")
  (verify-false (= #\A #\B) "A /= B")
  (verify-true (< #\A #\B) "A < B")
  (verify-false (< #\A #\A) "A /< A")
  (verify-true (> #\B #\A) "B > A")
  (verify-false (> #\B #\B) "B /> B")
  (verify-true (/= #\A #\N) "A /= N")
  (verify-false (/= #\A #\A) "A = A")
  (verify-equal (char-code #\A) 65 "A has character code 65")
  (verify-equal (code-char 66) #\B "Character code 66 is B")
  (verify-equal (char-downcase #\A) #\a "Lower case A is a")
  (verify-equal (char-upcase #\a) #\A "Upper case a is A")
  (verify-equal (char-code #\space) 32 "#\space represents a space")
  (verify-equal (char-code #\newline) 10 "#\newline represents a line feed")
  (verify-equal (char-code #\tab) 9 "#\tab represents a tab")
  (verify-equal (char-code #\page) 12 "#\page represents a form feed")
  (verify-equal (char-code #\rubout) 127 "#\rubout represents a delete")
  (verify-equal (char-code #\linefeed) 10 "#\linefeed represents a line feed")
  (verify-equal (char-code #\return) 13 "#\return represents a carriage return")
  (verify-equal (char-code #\backspace) 8 "#\backspace represents a backspace")
  (verify-equal ERR_PARSECHAR #\bad "#\bad is an error")
  (verify-equal ERR_PARSECHAR (car #!) "Invalid special sequence"))
(test-char)
(setq test-char 0)
;
;  Test string operations
;
(print "===> Testing strings")
(terpri)
(defun test-str ()
  (verify-equal 5 (length "Hello") "Length of hello")
  (verify-equal 26 (length "abcdefghijklmnopqrstuvwxyz") "Length of alphabet")
  (verify-equal 4 (length (list 1 2 3 4)) "Length of list")
  (verify-equal 1 (length 1) "Length of integer")
  (verify-equal 0 (length ()) "Length of empty list")
  (verify-equal #\z (char "abcdefghijklmnopqrstuvwxyz" 25) "Last letter of alphabet")
  (verify-equal #\a (char "abcdefghijklmnopqrstuvwxyz" 0) "First letter of alphabet")
  (verify-equal 42 (parse-integer "42") "The meaning of life")
  (verify-equal -100 (parse-integer "-100") "Negative number")
  (verify-equal 0 (parse-integer "hello") "Not a number")
  (verify-equal "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123"
    (string-upcase "abcdefghijklmnopqrstuvwxyz0123") "Upper case text")
  (verify-equal "abcdefghijklmnopqrstuvwxyz0123"
    (string-downcase "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123") "Lower case text")
  (verify-equal "-bye" (subseq "Good-bye" 4) "Subsequence with default end")
  (verify-equal "d-b" (subseq "Good-bye" 3 6) "Subsequence with specified end")
  (verify-equal "fairly long string t"
    (subseq "This is a fairly long string that should span multiple fragments" 10 30)
    "Subsequence of a long string"))
(test-str)
(setq test-str 0)
;
;  Test predicates
;
(print "===> Testing predicates")
(terpri)
(defun test-pred ()
  (verify-false (arrayp (1 3 4)) "arrayp is always false")
  (verify-false (bit-vector-p (1 2 3)) "bit-vector-p is always false")
  (verify-false (complexp 1) "complexp is always false")
  (verify-false (floatp (/ 1 3)) "floatp is always false")
  (verify-false (vectorp (1 2 3)) "vectorp is always false")
  (verify-false (rationalp (/ 2 5)) "rationalp is always false")
  (verify-false (realp (/ 5 2)) "realp is always false")
  (verify-false (simple-vector-p (1 2 3)) "simple-vector-p is always false")
  (verify-false (simple-bit-vector-p #x0F0F0F0F) "simple-bit-vector-p is always false")
  (verify-false (packagep "main") "packagep is always false")
  (verify-false (vectorp (1 2 3)) "vectorp is always false")
  (verify-true (atomp 1) "atomp is true for atoms")
  (verify-false (atomp (1)) "atomp is false for non-atoms")
  (verify-true (characterp #\A) "characterp is true for characters")
  (verify-false (characterp 1) "characterp is false for non-characters")
  (verify-true (compiled-function-p print) "compiled-function-p is true for builtins")
  (verify-false (compiled-function-p test-pred) "compiled-function-p is false for non-builtins")
  (verify-true (consp (1 2 3)) "consp is true for lists")
  (verify-false (consp 1) "consp is false for non-lists")
  (verify-false (errorp 1) "errorp is false for normal conditions")
  (verify-true (errorp (+ 1 "a")) "errorp is true for error conditions")
  (verify-true (functionp test-pred) "functionp is true for user defined functions")
  (verify-true (functionp functionp) "functionp is true for builtin functions")
  (verify-true (functionp setq) "functionp is true for special functions")
  (verify-true (functionp (lambda (a b) (+ a b))) "functionp is true for lambda functions")
  (verify-false (functionp 1) "functionp is false for non-functions")
  (verify-true (integerp 3) "integerp is true for integers")
  (verify-false (integerp #\A) "integerp is false for non-integers")
  (verify-true (listp (2 4 6)) "listp is true for lists")
  (verify-false (listp "Hello") "listp is false for non-lists")
  (verify-true (numberp 10) "numberp is true for numbers")
  (verify-false (numberp #\B) "numberp is false for non-numbers")
  (verify-true (null ()) "null is true for nulls")
  (verify-false (null 1) "null is false for non-nulls")
  (verify-true (simple-string-p "Hello") "simple-string-p is true for strings")
  (verify-false (simple-string-p 2) "simple-string-p is false for non-strings")
  (verify-true (stringp "Hello") "stringp is true for strings")
  (verify-false (stringp #\C) "stringp is false for non-strings")
  (verify-true (symbolp car) "symbolp is true for symbols")
  (verify-false (symbolp #\@) "symbolp is false for non-symbol"))
(test-pred)
(setq test-pred 0)
;
;  Test coerce and quoted symbols
;
(print "===> Testing coercion")
(terpri)
(defun test-coerce ()
  (verify-equal 1 (coerce t 'integer) "Boolean to integer")
  (verify-equal 0 (coerce nil 'integer) "Boolean to integer")
  (verify-equal 123 (coerce 123 'integer) "Integer to integer")
  (verify-equal "T" (coerce t 'string) "Boolean to string")
  (verify-equal "NIL" (coerce nil 'string) "Boolean to string")
  (verify-equal 1 (coerce t 'integer) "Boolean to integer")
  (verify-equal ERR_WRONGTYPE (coerce "A" 'integer) "String to integer is error")
  (verify-equal NIL (coerce nil 'boolean) "Boolean to boolean")
  (verify-equal ERR_WRONGTYPE (coerce 1 'string) "Integer to string is error")
  (verify-equal "A" (coerce #\A 'string) "Character to string")
  (verify-equal "@" (coerce #\@ 'string) "Character to string")
  (verify-equal "Hello" (coerce "Hello" 'string) "String to string")
  (verify-equal #\A (coerce #\A 'character) "Character to character")
  (verify-equal ERR_WRONGTYPE (coerce 1 'character) "Integer to character is error")
  (verify-equal ERR_WRONGTYPE (coerce #\A 'boolean) "Character to boolean is error")
  (verify-equal T (coerce 1 'boolean) "Integer to boolean")
  (verify-equal NIL (coerce 0 'boolean) "Integer to boolean")
  (verify-equal ERR_NOPARAM (coerce) "Called with no parameters")
  (verify-equal ERR_WRONGTYPE (coerce 1) "Called with only one parameter")
  (verify-equal ERR_PARSECHAR (coerce #\error 'string) "First parameter is an error")
  (verify-equal ERR_WRONGTYPE (coerce 1 1) "Second parameter is not a symbol")
  (verify-equal ERR_WRONGTYPE (coerce 1 'print) "Second parameter does not represent a type")
  (verify-equal ERR_WRONGTYPE (coerce (1 2 3) 'string) "First parameter is a list")
  (verify-equal ERR_PARSECHAR (coerce 1 #\error) "Second parameter is an error")
  (verify-equal ERR_WRONGTYPE (coerce 1 (1 2 3)) "Second parameter is a list"))
(test-coerce)
(setq test-coerce 0)
;
;  Test concatenation of strings.  Lists can't be compared so
;  they aren't tested.
;
(print "==> Testing concatenation")
(terpri)
(defun test-concatenate ()
  (verify-equal "Hello world!" (concatenate 'string "Hello" " " "world" "!") "String concatenation")
  (verify-equal "This is a longer string that spans multiple fragments. Another fairly long string"
   (concatenate 'string "This is a longer string that spans multiple fragments" ". "
      "Another fairly long string") "Concatenate long strings")
  (verify-false (errorp (concatenate 'list (1 2 3) (4 5 6))) "Concatenate lists")
  (verify-equal 6 (length (concatenate 'list (1 2 3) (4 5 6))) "Concatenate lists")
  (verify-equal ERR_NOPARAM (concatenate) "Concatenate with no parameters")
  (verify-equal ERR_WRONGTYPE (concatenate 1 "A" "B") "Concatenate with first parameter not symbol")
  (verify-equal ERR_PARSECHAR (concatenate #\error "A" "B") "Concatenate with first parameter error")
  (verify-equal ERR_WRONGTYPE (concatenate (1 2 3) (4 5 6)) "Concatenate with first parameter a list")
  (verify-equal ERR_WRONGTYPE (concatenate 'integer 1 1) "Can't concatenate integers")
  (verify-equal ERR_WRONGTYPE (concatenate 'string 1 2 3) "Integers aren't strings")
  (verify-equal ERR_WRONGTYPE (concatenate 'string "A" (1 2 3)) "Mixed concatenation")
  (verify-equal ERR_FEWPARAM (concatenate 'string) "Concatenate no strings")
  (verify-equal ERR_FEWPARAM (concatenate 'list) "Concatenate no lists")
  (verify-equal ERR_PARSECHAR (concatenate 'string #\error) "Error as second parameter")
  (verify-equal ERR_PARSECHAR (concatenate 'list #\error) "Error as second parameter"))
(test-concatenate)
(setq test-concatenate 0)
;
;  Test lambda and function passing
;
(print "==> Testing Lambda and function passing")
(terpri)
(defun test-lambda (a b c d)
  (verify-equal a (b c d) "Testing lambda"))
(defun add (a b) (+ a b))
(test-lambda 3 (lambda (a1 a2) (+ a1 a2)) 1 2)
(test-lambda 9 add 4 5)
(test-lambda 6 (lambda (a1 a2) (* a1 a2)) 2 3)
(test-lambda 12 * 3 4)
(test-lambda T (lambda (a1 a2) (< a1 a2)) #\A #\B)
(test-lambda T (lambda (a1 a2)(= a1 (* a2 (/ a1 a2)))) 6 2)
(setq test-lambda 0)
;
;  Test miscellaneous items.  These have out of band effects, so the
;  checks mainly test that they properly recognize valid and invalid
;  parameters.
;
(print "===> Testing miscellaneous operations")
(terpri)
(defun test-misc ()
  (verify-equal NIL (msg T) "Message on returns NIL")
  (verify-equal NIL (msg NIL) "Message off returns NIL")
  (verify-equal ERR_NOPARAM (msg) "No parameter to message")
  (verify-equal ERR_WRONGTYPE (msg print) "Symbol parameter to message")
  (verify-equal ERR_PARSECHAR (msg #\error) "Error parameter to message")
  (verify-equal ERR_WRONGTYPE (msg "Hello") "String parameter to message")
  (verify-equal NIL (dump) "Dump returns NIL")
  (verify-equal NIL (sleep 1) "Sleep returns NIL")
  (verify-equal ERR_NOPARAM (sleep) "No parameter to sleep")
  (verify-equal ERR_PARSECHAR (sleep #\error) "Error parameter to sleep")
  (verify-equal ERR_WRONGTYPE (sleep print) "Symbol parameter to sleep")
  (verify-equal ERR_WRONGTYPE (sleep "Wake") "String parameter to sleep"))
(test-misc)
(setq test-misc 0)
;
;  Test I/O operations.  These have out of band effects, so the
;  checks mainly test that proper values are returned and that errors
;  don't occur for valid inputs.
;
(print "===> Testing I/O operations")
(terpri)
(defun test-io ()
  (verify-equal NIL (print 1) "Print integer returns NIL")
  (verify-equal NIL (print #\1) "Print character returns NIL")
  (verify-equal NIL (print "1") "Print string returns NIL")
  (verify-equal NIL (print 'print) "Print quoted symbol returns NIL")
  (verify-equal NIL (print print) "Print builting symbol returns NIL")
  (verify-equal NIL (print (1 2 3)) "Print list returns NIL")
  (verify-equal NIL (print ()) "Print empty list returns NIL")
  (let (a)
    (verify-equal NIL (print a) "Print empty local variable returns NIL")
    (setq a (1 2 3))
    (verify-equal NIL (print a) "Print list local variable returns NIL")
    (setq a 'print)
    (verify-equal NIL (print a) "Print quoted symbol local variable returns NIL")
    (setq a print)
    (verify-equal NIL (print a) "Print symbol local variable returns NIL")
    (setq a (lambda (c) (+ 1 c)))
    (verify-equal NIL (print a) "Print lambda local variable returns NIL")
    (verify-equal NIL (print b) "Print unknown variable returns NIL"))
  (verify-equal NIL (terpri) "Terpri returns NIL")
  (verify-equal NIL (fresh-line) "Fresh-line returns NIL")
  (verify-equal NIL (progn (print "Hello") (fresh-line)) "Fresh-line returns NIL")
  (verify-equal "Testing a longer line that should be split across fragments."
    (read-line) "Text read from read-line"))
(test-io)
Testing a longer line that should be split across fragments.
(setq test-io 0)
;
;  Test read expression operation
;
(print "===> Testing read expression operations")
(terpri)
(defun test-read ()
  (let ((temp (read "(1 2 3)")))
    (verify-equal 3 (length temp) "Correct number of items parsed")
    (verify-equal 1 (car temp) "First item is correct"))
  (let ((temp (read "(+ 1 2 3 4 -5 -6 -7 -8)")))
    (verify-equal 9 (length temp) "Longer list parsed")
    (verify-equal + (car temp) "First item is addition symbol"))
  (verify-equal ERR_NOPARAM (read) "Read needs a parameter")
  (verify-equal ERR_WRONGTYPE (read 1) "Read parameter needs to be a string")
  (verify-equal ERR_PARSE (read "(1 2 3") "Parse list error")
  (verify-equal ERR_PARSE (read "(1 2 ; Comment)") "Parse with a comment")
  (verify-equal 123 (read "123") "Read an integer")
  (verify-true (read "t") "Read true")
  (verify-false (read "nil") "Read nil"))
(test-read)
(setq test-read 0)
;
;  Test eval operation
;
(print "===> Testing eval operations")
(terpri)
(defun test-eval ()
  (verify-equal 4 (eval (read "(+ 1 2 1)")) "Simple addition")
  (verify-equal ERR_NOPARAM (eval) "No parameter to eval")
  (verify-equal 1 (eval 1) "Integer parameter to eval")
  (verify-equal ERR_PARSE (eval (read "(+ 1 2")) "Error passed to eval")
  (verify-equal 0 (eval *FAIL-COUNT*) "There should be no failures")
)
(test-eval)
(setq test-eval 0)
;
;  Test memory operations.  These read and write arbitrary memory, which
;  can have unpleasant side effects.  Only the error cases are tested.
;
(print "===> Testing memory operation errors")
(terpri)
(defun test-mem-err ()
  (verify-equal ERR_NOPARAM (peek8) "No parameter to peek8")
  (verify-equal ERR_NOPARAM (peek16) "No parameter to peek16")
  (verify-equal ERR_NOPARAM (peek32) "No parameter to peek32")
  (verify-equal ERR_WRONGTYPE (peek8 "Hello") "String parameter to peek8")
  (verify-equal ERR_WRONGTYPE (peek16 "Hello") "String parameter to peek16")
  (verify-equal ERR_WRONGTYPE (peek32 "Hello") "String parameter to peek32")
  (verify-equal ERR_NOPARAM (poke8) "No parameter to poke8")
  (verify-equal ERR_NOPARAM (poke16) "No parameter to poke16")
  (verify-equal ERR_NOPARAM (poke32) "No parameter to poke32")
  (verify-equal ERR_FEWPARAM (poke8 1) "One parameter to poke8")
  (verify-equal ERR_FEWPARAM (poke16 1) "One parameter to poke16")
  (verify-equal ERR_FEWPARAM (poke32 1) "One parameter to poke32")
  (verify-equal ERR_WRONGTYPE (poke8 "Hello" 1) "String parameter to poke8")
  (verify-equal ERR_WRONGTYPE (poke16 "Hello" 1) "String parameter to poke16")
  (verify-equal ERR_WRONGTYPE (poke32 "Hello" 1) "String parameter to poke32")
  (verify-equal ERR_WRONGTYPE (poke8 1 "Hello") "String parameter to poke8")
  (verify-equal ERR_WRONGTYPE (poke16 1 "Hello") "String parameter to poke16")
  (verify-equal ERR_WRONGTYPE (poke32 1 "Hello") "String parameter to poke32"))
(test-mem-err)
(setq test-mem-err 0)
;
;  Test list operations.  Since list comparisons aren't currently supported,
;  these aren't quite as nice as they might be.
;
(print "===> Testing list operations")
(terpri)
(defun test-list ()
  (verify-equal 3 (length (1 2 3)) "Length of a raw list")
  (verify-equal 4 (length (quote "a" "B" 3 4)) "Length of a quoted list")
  (verify-equal 5 (car (5 1 2 3 4)) "CAR of a list")
  (verify-equal 4 (length (cdr (5 6 7 8 9))) "Length of CDR")
  (verify-equal 2 (length (cons (2 3 4) 1)) "CONS of elements")
  (verify-equal 4 (length (cons 1 (2 3 4))) "CONS of elements")
  (verify-equal 1 (car (cons 1 (2 3 4))) "CAR of a CONS")
  (verify-equal 2 (car (cdr (1 2 3 4))) "CAR of a CDR of a list")
  (verify-equal 5 (car 5) "CAR of a single value")
  (verify-equal NIL (car) "CAR of nothing is nothing")
  (verify-equal NIL (cdr) "CDR of nothing is nothing")
  (varify-equal NIL (cdr 1) "CDR of a value is nothing")
  (verify-equal ERR_NOPARAM (cons) "No parameter to CONS")
  (verify-equal ERR_PARSECHAR (cons #\error 1) "CONS error in first parameter")
  (verify-equal ERR_PARSECHAR (cons 1 #\error) "CONS error in second parameter")
  (verify-equal ERR_PARSECHAR (list #\error 1 2 3) "LIST error in first parameter")
  (verify-equal ERR_PARSECHAR (list 1 2 #\error 3) "LIST error in later parameter")
  (verify-equal NIL (list) "LIST with no parameters is nothing")
  (verify-equal 5 (car (rplaca (1 2 3 4) 5)) "Replace CAR of first element in list")
  (verify-equal 2 (car (cdr (rplaca (1 2 3 4) 5))) "Replace CAR of first element in list (rest of list)")
  (verify-equal 6 (car (cdr (rplacd (1 2 3 4) (6 7)))) "Replace CDR of first element in list (rest of list)")
  (verify-equal ERR_NOPARAM (rplaca) "RPLACA with no parameters")
  (verify-equal ERR_WRONGTYPE (rplaca 1 1) "RPLACA needs a list")
  (verify-equal ERR_NOPARAM (rplacd) "RPLACD with no parameters")
  (verify-equal ERR_WRONGTYPE (rplacd 1 1) "RPLACD needs a list"))
(test-list)
(setq test-list 0)
;
;  Test error conditions.  There are lots so they will be broken down into smaller
;  groups.
;
(print "==> Testing comparison error conditions")
(terpri)
(defun test-cmp-err ()
  (verify-equal ERR_NOPARAM (=) "No parameters to equal")
  (verify-equal ERR_FEWPARAM (= 1) "One parameters to equal")
  (verify-equal ERR_WRONGTYPE (= 1 "A") "Mismatched parameters to equal")
  (verify-equal ERR_NOPARAM (/=) "No parameters to not-equal")
  (verify-equal ERR_FEWPARAM (/= 1) "One parameters to not-equal")
  (verify-equal ERR_WRONGTYPE (/= 1 "A") "Mismatched parameters to not-equal")
  (verify-equal ERR_NOPARAM (<) "No parameters to less-than")
  (verify-equal ERR_FEWPARAM (< 1) "One parameters to less-than")
  (verify-equal ERR_WRONGTYPE (< 1 "A") "Mismatched parameters to less-than")
  (verify-equal ERR_NOPARAM (>) "No parameters to greater-than")
  (verify-equal ERR_FEWPARAM (> 1) "One parameters to greater-than")
  (verify-equal ERR_WRONGTYPE (> 1 "A") "Mismatched parameters to greater-than")
  (verify-equal ERR_WRONGTYPE (> 'print 'terpri) "Symbols are not ordered")
  (verify-equal ERR_WRONGTYPE (< 'print 'terpri) "Symbols are not ordered")
  (verify-equal ERR_WRONGTYPE (= print 1) "Symbol in first parameter")
  (verify-equal ERR_WRONGTYPE (/= 1 print) "Symbol in second parameter")
  (verify-equal ERR_WRONGTYPE (= #\error 1) "Error in first parameter")
  (verify-equal ERR_WRONGTYPE (/= 1 #\error) "Error in second parameter")
  (verify-equal ERR_WRONGTYPE (< (1 2 3) 1) "List in first parameter")
  (verify-equal ERR_WRONGTYPE (> 1 (1 2 3)) "List in second parameter")
  (verify-equal ERR_NOPARAM (if (msg) 1 2) "Error in if condition")
  (verify-equal ERR_NOPARAM (if T (msg) 2) "Error in if true branch")
  (verify-equal ERR_NOPARAM (if NIL 1 (msg)) "Error in if false branch")
  (verify-equal ERR_NOPARAM (if) "No parameters to if"))
(test-cmp-err)
(setq test-cmp-err 0)
;
(print "==> Testing math error conditions")
(terpri)
(defun test-math-err ()
  (verify-equal ERR_NOPARAM (+) "No parameters to addition")
  (verify-equal ERR_WRONGTYPE (+ 1 "A") "Mismatched parameters to addition")
  (verify-equal ERR_WRONGTYPE (+ 1 (msg)) "Error parameter to addition")
  (verify-equal ERR_WRONGTYPE (+ 1 (1 2 3)) "Error parameter to addition")
  (verify-equal ERR_NOPARAM (-) "No parameters to subtraction")
  (verify-equal ERR_WRONGTYPE (- 1 "A") "Mismatched parameters to subtraction")
  (verify-equal ERR_WRONGTYPE (- 1 (msg)) "Error parameter to subtraction")
  (verify-equal ERR_WRONGTYPE (- 1 (1 2 3)) "Error parameter to subtraction")
  (verify-equal ERR_NOPARAM (/) "No parameters to division")
  (verify-equal ERR_WRONGTYPE (/ 1 "A") "Mismatched parameters to division")
  (verify-equal ERR_WRONGTYPE (/ 1 (msg)) "Error parameter to division")
  (verify-equal ERR_WRONGTYPE (/ 1 (1 2 3)) "Error parameter to division")
  (verify-equal ERR_NOPARAM (*) "No parameters to multiplication")
  (verify-equal ERR_WRONGTYPE (* "A" 1) "Mismatched parameters to multiplication")
  (verify-equal ERR_WRONGTYPE (* (msg) 1) "Error parameter to multiplication")
  (verify-equal ERR_WRONGTYPE (* (1 2 3) 1) "Error parameter to multiplication"))
(test-math-err)
(setq test-math-err 0)
;
(print "==> Testing logical operation error conditions")
(terpri)
(defun test-log-err ()
  (verify-equal ERR_NOPARAM (not) "No parameter to NOT")
  (verify-equal ERR_WRONGTYPE (not "A") "Invalid parameter type to NOT")
  (verify-equal ERR_PARSECHAR (not #\error) "Error parameter type to NOT")
  (verify-equal ERR_WRONGTYPE (not print) "Symbol parameter type to NOT")
  (verify-equal ERR_WRONGTYPE (not (1 2 3)) "List parameter type to NOT")
  (verify-equal ERR_NOPARAM (and) "No parameter to AND")
  (verify-equal ERR_WRONGTYPE (and "A") "Invalid parameter type to AND")
  (verify-equal ERR_WRONGTYPE (and T 1) "Mixed parameter types to AND")
  (verify-equal ERR_WRONGTYPE (and T (msg)) "Error parameter type to AND")
  (verify-equal ERR_WRONGTYPE (and T (1 2 3)) "List parameter type to AND")
  (verify-equal ERR_NOPARAM (or) "No parameter to OR")
  (verify-equal ERR_WRONGTYPE (or "A") "Invalid parameter type to OR")
  (verify-equal ERR_WRONGTYPE (or 1 NIL) "Mixed parameter types to OR")
  (verify-equal ERR_WRONGTYPE (or NIL (msg)) "Error parameter type to OR")
  (verify-equal ERR_WRONGTYPE (or 0 (1 2 3)) "List parameter type to OR"))
(test-log-err)
(setq test-log-err 0)
;
(print "==> Testing character operation error conditions")
(terpri)
(defun test-log-err ()
  (verify-equal ERR_NOPARAM (char-code) "No parameter to char-code")
  (verify-equal ERR_WRONGTYPE (char-code "A") "Invalid parameter type to char-code")
  (verify-equal ERR_WRONGTYPE (char-code (1 2 3)) "List parameter type to char-code")
  (verify-equal ERR_PARSECHAR (char-code #\error) "Error parameter type to char-code")
  (verify-equal ERR_WRONGTYPE (char-code print) "Symbol parameter type to char-code")
  (verify-equal ERR_NOPARAM (code-char) "No parameter to code-char")
  (verify-equal ERR_WRONGTYPE (code-char "A") "Invalid parameter type to code-char")
  (verify-equal ERR_WRONGTYPE (code-char (1 2 3)) "List parameter type to code-char")
  (verify-equal ERR_PARSECHAR (code-char #\error) "Error parameter type to code-char")
  (verify-equal ERR_WRONGTYPE (code-char print) "Symbol parameter type to code-char")
  (verify-equal ERR_RANGE (code-char 256) "Out of range parameter to code-char")
  (verify-equal ERR_NOPARAM (char-downcase) "No parameter to char-downcase")
  (verify-equal ERR_WRONGTYPE (char-downcase "A") "Invalid parameter type to char-downcase")
  (verify-equal ERR_WRONGTYPE (char-downcase (1 2 3)) "List provided to char-downcase")
  (verify-equal ERR_PARSECHAR (char-downcase #\error) "Error provided to char-downcase")
  (verify-equal ERR_WRONGTYPE (char-downcase print) "Symbol provided to char-downcase")
  (verify-equal ERR_NOPARAM (char-upcase) "No parameter to char-upcase")
  (verify-equal ERR_WRONGTYPE (char-upcase "A") "Invalid parameter type to char-upcase")
  (verify-equal ERR_WRONGTYPE (char-upcase (1 2 3)) "List provided to char-upcase")
  (verify-equal ERR_PARSECHAR (char-upcase #\error) "Error provided to char-upcase")
  (verify-equal ERR_WRONGTYPE (char-upcase print) "Error provided to char-upcase"))
(test-log-err)
(setq test-log-err 0)
;
(print "==> Testing string operation error conditions")
(terpri)
(defun test-log-err ()
  (verify-equal ERR_NOPARAM (char) "No parameter to char")
  (verify-equal ERR_WRONGTYPE (char print 1) "Symbol first parameter type to char")
  (verify-equal ERR_WRONGTYPE (char "A" print) "Symbol second parameter type to char")
  (verify-equal ERR_WRONGTYPE (char 1 1) "Invalid first parameter type to char")
  (verify-equal ERR_WRONGTYPE (char "A" "A") "Invalid second parameter type to char")
  (verify-equal ERR_RANGE (char "AB" 10) "Out of range second parameter type to char")
  (verify-equal ERR_RANGE (char "ABCDEFGHIJKLMNOPQRSTUVWXYZ" 40) "Out of range second parameter type to char")
  (verify-equal ERR_NOPARAM (parse-integer) "No parameter to parse-integer")
  (verify-equal ERR_WRONGTYPE (parse-integer 1) "Non string parameter to parse-integer")
  (verify-equal ERR_WRONGTYPE (parse-integer #\error) "Error string parameter to parse-integer")
  (verify-equal ERR_NOPARAM (string-downcase) "No parameter to string-downcase")
  (verify-equal ERR_WRONGTYPE (string-downcase 1) "Integer parameter type to string-downcase")
  (verify-equal ERR_WRONGTYPE (string-downcase print) "Symbol parameter type to string-downcase")
  (verify-equal ERR_NOPARAM (string-upcase) "No parameter to string-upcase")
  (verify-equal ERR_WRONGTYPE (string-upcase \#b) "Character parameter type to string-upcase")
  (verify-equal ERR_WRONGTYPE (string-upcase print) "Symbol parameter type to string-upcase")
  (verify-equal ERR_NOPARAM (subseq) "No parameter type to subseq")
  (verify-equal ERR_WRONGTYPE (subseq 1 2 3) "Invalid first parameter type to subseq")
  (verify-equal ERR_WRONGTYPE (subseq print 2 3) "Symbol first parameter type to subseq")
  (verify-equal ERR_WRONGTYPE (subseq "ABC" print 2) "Symbol second parameter type to subseq")
  (verify-equal ERR_WRONGTYPE (subseq "ABC" 3 print) "Symbol third parameter type to subseq")
  (verify-equal ERR_RANGE (subseq "A" 2 3) "out of range parameter to subseq")
  (verify-equal ERR_WRONGTYPE (subseq "ABC" #\a 3) "Invalid parameter type to subseq")
  (verify-equal ERR_WRONGTYPE (subseq "ABC" 1 #\b) "Invalid parameter type to subseq"))
(test-log-err)
(setq test-log-err 0)
;
(print "===> Testing predicate error conditions")
(terpri)
(defun test-pred-err ()
;
;  Test cases commented out because as these types are not supported in
;  Tiny-Lisp, the predicates for them always return false even with no
;  parameters.
;
;  (verify-equal ERR_NOPARAM (arrayp) "No parameter to arrayp")
;  (verify-equal ERR_NOPARAM (bit-vector-p) "No parameter to bit-vector-p")
;  (verify-equal ERR_NOPARAM (complexp) "No parameter to complexp")
;  (verify-equal ERR_NOPARAM (floatp) "No parameter to floatp")
;  (verify-equal ERR_NOPARAM (vectorp) "No parameter to vectorp")
;  (verify-equal ERR_NOPARAM (rationalp) "No parameter to rationalp")
;  (verify-equal ERR_NOPARAM (realp) "No parameter to realp")
;  (verify-equal ERR_NOPARAM (simple-vector-p) "No parameter to simple-vector-p")
;  (verify-equal ERR_NOPARAM (simple-bit-vector-p) "No parameter to simple-bit-vector-p")
;  (verify-equal ERR_NOPARAM (packagep) "No parameter to packagep")
;  (verify-equal ERR_NOPARAM (vectorp) "No parameter to vectorp")
  (verify-equal ERR_NOPARAM (atomp) "No parameter to atomp")
  (verify-equal ERR_NOPARAM (characterp) "No parameter to characterp")
  (verify-equal ERR_NOPARAM (compiled-function-p) "No parameter to compiled-function-p")
  (verify-equal ERR_NOPARAM (consp) "No parameter to consp")
  (verify-equal ERR_NOPARAM (errorp) "No parameter to errorp")
  (verify-equal ERR_NOPARAM (functionp) "No parameter to functionp")
  (verify-equal ERR_NOPARAM (integerp) "No parameter to integerp")
  (verify-equal ERR_NOPARAM (listp) "No parameter to listp")
  (verify-equal ERR_NOPARAM (numberp) "No parameter to numberp")
  (verify-equal ERR_NOPARAM (null) "No parameter to null")
  (verify-equal ERR_NOPARAM (simple-string-p) "No parameter to simple-string-p")
  (verify-equal ERR_NOPARAM (stringp) "No parameter to stringp")
  (verify-equal ERR_NOPARAM (symbolp) "No parameter to symbolp"))
(test-pred-err)
(setq test-pred-err 0)
;
(print "===> Testing coercion errors")
(terpri)
(defun test-coerce-err ()
  (verify-equal ERR_NOPARAM (coerce) "No parameters")
  (verify-equal ERR_WRONGTYPE (coerce nil) "One parameter")
  (verify-equal ERR_WRONGTYPE (coerce t 'print) "Wrong coercion")
  (verify-equal ERR_WRONGTYPE (coerce nil 'character) "Invalid coercion"))
(test-coerce-err)
(setq test-coerce-err 0)
;
(print "==> Testing concatenation errors")
(terpri)
(defun test-concatenate-err ()
  (verify-equal ERR_NOPARAM (concatenate) "No parameters")
  (verify-equal ERR_FEWPARAM (concatenate 'string) "One parameter")
  (verify-equal ERR_WRONGTYPE (concatenate 'print "Hello " "World") "Invalid type")
  (verify-equal ERR_WRONGTYPE (concatenate 'list (1 2 3) "world") "Wrong type")
  (verify-equal ERR_WRONGTYPE (concatenate 'string (1 2 3) "world") "Wrong type")
  (verify-equal ERR_WRONGTYPE (concatenate 'string "Hello " 1) "Wrong type"))
(test-concatenate-err)
(setq test-concatenate-err 0)
;
;  Testing function errors is a bit difficult because defining functions
;  within functions is not supported.
;
(print "===> Testing function errors")
(terpri)
(defun test1 (a) (print (+ a 1)))
(verify-equal ERR_FEWPARAM (test1) "Function called with wrong number of parameters")
(verify-equal ERR_NOPARAM (defun) "No parameters to defun")
(verify-equal ERR_FEWPARAM (defun print) "Redefine a builtin")
(verify-equal ERR_FEWPARAM (defun 3) "Function name must be a symbol")
(verify-equal ERR_FEWPARAM (defun test1) "Only function name provided")
(verify-equal ERR_WRONGTYPE (defun test1 1 (print (+ 1 1))) "Parameter list is not a list")
(verify-equal ERR_WRONGTYPE (defun test1 (1) (print (+ 1 1))) "Parameter is a value")
(verify-equal ERR_WRONGTYPE (defun test1 (print) (print (+ 1 1))) "Parameter is a builtin")
(verify-equal ERR_WRONGTYPE (defun test1 ((1)) (print (+ 1 1))) "Parameter is a list")
(verify-equal ERR_NOPARAM (lambda) "Lambda with no parameters")
(verify-equal ERR_FEWPARAM (lambda 1 (print (+ 1 1))) "Lambda parameters must be a list")
(verify-equal ERR_FEWPARAM (lambda (1) (print (+ 1 1))) "lambda with value parameter")
(verify-equal ERR_FEWPARAM (lambda (print) (print (+ 1 1))) "lambda with builtin symbol parameter")
(verify-equal ERR_FEWPARAM (lambda ((1)) (print (+ 1 1))) "lambda with list parameter")
;
(print "===> Testing DOWHILE errors")
(terpri)
(defun check-err (b) (if (< b 3) b #\error))
(defun test-dowhile-err ()
  (verify-equal ERR_NOPARAM (dowhile) "No parameters to dowhile")
  (verify-equal ERR_PARSECHAR (dowhile #\error (print "Hello")) "Error in condition")
  (let ((a 0))
    (verify-equal ERR_WRONGTYPE (dowhile (< a 3) (setq a (+ a 1)) (+ 1 #\error)) "Error in block"))
  (let ((a 0))
    (verify-equal ERR_PARSECHAR (dowhile (check-err a) (setq a (+ a 1))) "Error later in condition")))
(test-dowhile-err)
(setq test-dowhile-err 0)
(setq check-err 0)
;
(print "===> Testing DOLIST errors")
(terpri)
(defun test-dotimes-err ()
  (verify-equal ERR_NOPARAM (dolist) "No parameters to dolist")
  (verify-equal ERR_FEWPARAM (dolist 1 1) "Limits need to be a list")
  (verify-equal ERR_FEWPARAM (dolist ((1 2 3) 1 2) (print "Hi")) "Loop variable is a list")
  (verify-equal ERR_FEWPARAM (dolist ('print 1 2) (print "Hi")) "Loop variable is a builtin")
  (verify-equal ERR_FEWPARAM (dolist (1) 1) "No limit variable")
  (verify-equal ERR_FEWPARAM (dolist (a #\error) 1) "Error in limits")
  (verify-equal ERR_FEWPARAM (dolist (a -1) 1) "Limit is not a list")
  (verify-equal ERR_FEWPARAM (dolist (a 5) (+ 1 #\error)) "Error in loop body")
)
(test-dotimes-err)
(setq test-dotimes-err 0)
;
(print "===> Testing DOTIMES errors")
(terpri)
(defun test-dotimes-err ()
  (verify-equal ERR_NOPARAM (dotimes) "No parameters to dotimes")
  (verify-equal ERR_FEWPARAM (dotimes 1 1) "Limits need to be a list")
  (verify-equal ERR_WRONGTYPE (dotimes ((1 2 3) 1 2) (print "Hi")) "Loop variable is a list")
  (verify-equal ERR_WRONGTYPE (dotimes ('print 1 2) (print "Hi")) "Loop variable is a builtin")
  (verify-equal ERR_FEWPARAM (dotimes (1) 1) "No limit variable")
  (verify-equal ERR_WRONGTYPE (dotimes (a #\error) 1) "Error in limits")
  (verify-equal ERR_RANGE (dotimes (a -1) 1) "Limit is negative")
  (verify-equal ERR_WRONGTYPE (dotimes (a #\A) 1) "Limit is not integer")
  (verify-equal ERR_WRONGTYPE (dotimes (a 5) (+ 1 #\error)) "Error in loop body"))
(test-dotimes-err)
(setq test-dotimes-err 0)
;
(print "===> Testing string function errors")
(terpri)
(defun test-str-err ()
  (verify-equal ERR_NOPARAM (length) "No parameters to length")
  (verify-equal ERR_WRONGTYPE (char 1 1) "Char first parameter not string")
  (verify-equal ERR_WRONGTYPE (char (1 2 3) 1) "Char first parameter is a list")
  (verify-equal ERR_WRONGTYPE (char "Hello" #\A) "Char second parameter not integer")
  (verify-equal ERR_RANGE (char "Hello" -1) "Char index negative")
  (verify-equal ERR_RANGE (char "Hello" 100) "Char index too big")
  (verify-equal ERR_NOPARAM (parse-integer) "No parameter to parse-integer")
  (verify-equal ERR_WRONGTYPE (parse-integer 1) "Integer parameter to parse-integer")
  (verify-equal ERR_WRONGTYPE (parse-integer (1 2 3)) "List parameter to parse-integer")
  (verify-equal ERR_NOPARAM (subseq) "No parameters to subseq")
  (verify-equal ERR_PARSECHAR (subseq #\error 2 2) "Error in first parameter to subseq")
  (verify-equal ERR_WRONGTYPE (subseq 2 2 2) "First parameter of subseq is not string")
  (verify-equal ERR_WRONGTYPE (subseq (1 2 3) 2 2) "First parameter of subseq is a list")
  (verify-equal ERR_PARSECHAR (subseq "Hello" #\error 2) "Error in second parameter to subseq")
  (verify-equal ERR_WRONGTYPE (subseq "Hello" #\A 2) "Second parameter of subseq is not integer")
  (verify-equal ERR_WRONGTYPE (subseq "Hello" (1 2 3) 2) "Second parameter of subseq is a list")
  (verify-equal ERR_PARSECHAR (subseq "Hello" 2 #\error) "Error in third parameter to subseq")
  (verify-equal ERR_WRONGTYPE (subseq "Hello" 2 #\A) "Third parameter of subseq is not integer")
  (verify-equal ERR_WRONGTYPE (subseq "Hello" 2 (1 2 3)) "Third parameter of subseq is a list")
  (verify-equal ERR_RANGE (subseq "Hello" 3 2) "Subseq start is greater than end")
  (verify-equal ERR_RANGE (subseq "Hello" -1 2) "Subseq start is less than zero")
  (verify-equal ERR_NOPARAM (string-upcase) "No parameters to string-upcase")
  (verify-equal ERR_WRONGTYPE (string-upcase T) "Non-string parameter to string-upcase")
  (verify-equal ERR_PARSECHAR (string-upcase #\error) "Error parameter to string-upcase")
  (verify-equal ERR_WRONGTYPE (string-upcase (1 2 3)) "List parameter to string-upcase")
  (verify-equal ERR_NOPARAM (string-downcase) "No parameters to string-downcase")
  (verify-equal ERR_WRONGTYPE (string-downcase T) "Non-string parameter to string-downcase")
  (verify-equal ERR_WRONGTYPE (string-downcase (1 2 3)) "List parameter to string-downcase")
  (verify-equal ERR_PARSECHAR (string-downcase #\error) "Error parameter to string-downcase"))
(test-str-err)
(setq test-str-err 0)
;
(print "===> Testing variable function errors")
(terpri)
(defun test-var-errors ()
  (verify-equal ERR_NOPARAM (setq) "No parameters to setq")
  (verify-equal ERR_NOTSYM (setq 1 2) "Non-symbol parameter to setq")
  (verify-equal ERR_NOTSYM (setq (1 2 3) 2) "List parameter to setq")
  (verify-equal ERR_FIXSYM (setq print 3) "Builtin parameter to setq")
  (verify-equal ERR_NOTSYM (setq #\error 5) "Error parameter to setq")
  (verify-equal ERR_NOPARAM (let) "No parameters to let")
  (verify-equal ERR_WRONGTYPE (let a) "Single item parameter to let")
  (verify-equal ERR_WRONGTYPE (let 1) "Value parameter to let")
  (verify-equal ERR_STACK (let (1) (print "Hello")) "Value rather than a variable to let")
  (verify-equal ERR_STACK (let (#\error) (print "Hello")) "Error parameter to let")
  (verify-false (errorp (let ((a #\error)) (print "Hello"))) "Error value to let variable")
  (verify-equal ERR_WRONGTYPE (let ((a 1)) (+ 1 #\error)) "Error in body of let"))
(test-var-errors)
(setq test-var-errors 0)
;
;  Note that testing stack overflow errors depend on the stack size being
;  set to 100 and the current stack implementation.  Changes to these will
;  likely require changes to the tests.
;
(print "===> Testing stack overflow")
(terpri)
(defun test-stack-ovr (a) (print "A is " a) (terpri) (test-stack-ovr (+ 1 a)))
(verify-equal ERR_STACK (test-stack-ovr 1) "Recursive function stack overflow error")
(defun test-stack-ovr (a) (let (A1 A2 A3 A4 A5 A6 A7 A8 A9 A10) (print "A is " a) (terpri) (test-stack-ovr (+ 1 a))))
(verify-equal ERR_STACK (test-stack-ovr 1) "Recursive function with locals stack overflow error")
(verify-equal ERR_WRONGTYPE (let (A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
  A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28 A29 A30 A31 A32
  A33 A34 A35 A36 A37 A38 A39 A40 A41 A42 A43 A44 A45 A46 A47 A48 A49 A50
  A51 A52 A53 A54 A55 A56 A57 A58 A59 A60 A61 A62 A63 A64 A65 A66 A67 A68
  A69 A70 A71 A72 A73 A74 A75 A76 A77 A78 A79 A80 A81 A82 A83 A84 A85 A86
  A87 A88 A89 A90 A91 A92 A93 A94 A95 A96 A97 A98 A99 A100)
  (print "So many local variables") (terpri)) "Too many local variables")
(defun test-lambda (a b)
  (verify-equal a (b 1 2 3 4 5 6 7 8 9
  10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33
  34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57
  58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81
  82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100) "Testing lambda"))
(verify-equal ERR_WRONGTYPE (test-lambda T (lambda (A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A13 A14
  A15 A16 A17 A18 A19 A20 A21 A22 A23 A24 A25 A26 A27 A28 A29 A30 A31 A32
  A33 A34 A35 A36 A37 A38 A39 A40 A41 A42 A43 A44 A45 A46 A47 A48 A49 A50
  A51 A52 A53 A54 A55 A56 A57 A58 A59 A60 A61 A62 A63 A64 A65 A66 A67 A68
  A69 A70 A71 A72 A73 A74 A75 A76 A77 A78 A79 A80 A81 A82 A83 A84 A85 A86
  A87 A88 A89 A90 A91 A92 A93 A94 A95 A96 A97 A98 A99 A100)
  (print "So many parameters") (terpri))) "Lambda variables")
;
;  Testing other resource exhaustion errors
;
(print "===> Testing Resource exhaustion")
(terpri)
(defun test-str-error ()
  (let ((s "1234567890123456"))
    (dowhile T
      (setq s (concatenate 'string s "1234567890123456")))))
(verify-equal ERR_ALLOCSTR (test-str-error) "String exhaustion with full fragments")
;
(defun test-str-error ()
  (let ((s "123456789012345"))
    (dowhile T
      (setq s (concatenate 'string s "123456789012345")))))
(verify-equal ERR_ALLOCSTR (test-str-error) "String exhaustion with partial fragments")
;
(defun test-cons-error ()
  (let ((s (0 1)))
    (dowhile T
      (setq s (concatenate 'list s (list 0 1 3))))))
(verify-equal ERR_ALLOCCONS (test-cons-error) "Cons table exhaustion in concatenate")
;
(defun test-cons-error ()
  (let ((s (0 1)) (c 1))
    (dowhile T
      (setq s (cons c s))
      (setq c (+ 1 c)))))
(verify-equal ERR_ALLOCCONS (test-cons-error) "Cons table exhaustion in cons")
(setq test-cons-error 0)
;(dump)
(print "===> Testing complete")
(terpri)
(summary)
(exit)

